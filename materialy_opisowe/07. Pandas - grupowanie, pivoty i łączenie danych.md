## GroupBy i agregacje  

GroupBy pozwala podzieliÄ‡ dane na grupy wedÅ‚ug wybranego kryterium, a nastÄ™pnie wykonaÄ‡ na nich podsumowania, transformacje lub selekcje. To podstawowe narzÄ™dzie do analizy grupowej danych.

PrzykÅ‚adowy DataFrame:  

```python
import pandas as pd

data = {
    'Kategoria': ['A', 'A', 'B', 'B', 'C', 'C'],
    'Wartosc': [10, 15, 10, 20, 10, 30],
    'IloÅ›Ä‡': [1, 2, 1, 3, 1, 1]
}
df = pd.DataFrame(data)
```

### `groupby()`  

Dzieli DataFrame na grupy wedÅ‚ug wartoÅ›ci w kolumnie.  

```python
grupy = df.groupby('Kategoria')  

print(grupy)
```

Zadanie: Podziel df wedÅ‚ug 'Kategoria' i wyÅ›wietl Å›redniÄ… kolumny 'Wartosc' dla kaÅ¼dej grupy.

***

### `aggregate()`  

Pozwala wykonaÄ‡ rÃ³Å¼ne funkcje agregujÄ…ce na kolumnach grup.  

* zapis rozdzielony na wiele linii - nawiasy albo `\`

```python
agg = df.groupby('Kategoria').aggregate({'Wartosc': 'sum', 'IloÅ›Ä‡': 'max'})

print(agg)
```

Zadanie: Policz sumÄ™ 'Wartosc' oraz maksymalnÄ… 'IloÅ›Ä‡' dla kaÅ¼dej kategorii.

***

### `transform()`  

Zwraca wynik o takim samym ksztaÅ‚cie jak oryginaÅ‚, np. uÅ‚atwia normalizacjÄ™ danych wewnÄ…trz grup.  

```python
df['Åšrednia_w_grupie'] = df.groupby('Kategoria')['Wartosc'].transform('mean')
print(df)
```

Zadanie: Dodaj do df kolumnÄ™ z medianÄ… 'Wartosc' w kaÅ¼dej grupie.

***

### `first()` / `last()`  

Zwraca pierwszy lub ostatni wiersz z kaÅ¼dej grupy.  

```python
print(df.groupby('Kategoria').first())
print(df.groupby('Kategoria').last())
```

Sortowanie po kolumnie 'Wartosc' i wybÃ³r najnowszego (najwiÄ™kszego) oraz najstarszego (najmniejszego) rekordu w kaÅ¼dej grupie:

```python
# Najnowszy rekord (najwiÄ™ksza 'Wartosc') w kaÅ¼dej grupie
najnowszy = df.sort_values('Wartosc').groupby('Kategoria').last()
print(najnowszy)

# Najstarszy rekord (najmniejsza 'Wartosc') w kaÅ¼dej grupie
najstarszy = df.sort_values('Wartosc').groupby('Kategoria').first()
print(najstarszy)
```

NajczÄ™Å›ciej najpierw sortujemy dane wedÅ‚ug kolumny, ktÃ³ra nas interesuje (np. 'Wartosc'), a nastÄ™pnie grupujemy (`groupby`) i wybieramy pierwszy lub ostatni wiersz z kaÅ¼dej grupy. DziÄ™ki temu mamy pewnoÅ›Ä‡, Å¼e wybieramy rekordy zgodnie z ustalonym porzÄ…dkiem. PrzykÅ‚ad:

```python
# Najpierw sortujemy, potem grupujemy i wybieramy
najwyzszy = df.sort_values('Wartosc').groupby('Kategoria').last()
```

GdybyÅ›my najpierw zgrupowali, a potem sortowali, sortowanie dziaÅ‚aÅ‚oby juÅ¼ tylko w obrÄ™bie wynikÃ³w agregacji, a nie oryginalnych danych.

Zadanie: WyÅ›wietl pierwszy i ostatni wiersz kaÅ¼dej grupy 'Kategoria'.

***

## Tabele przestawne  

Pivot tables pozwalajÄ… przeksztaÅ‚caÄ‡ i podsumowywaÄ‡ dane Å‚atwo i szybko.  

```python
pivot = df.pivot_table(values='Wartosc', index='Kategoria', aggfunc='sum')
print(pivot)
```

Zadanie: UtwÃ³rz tabelÄ™ przestawnÄ… pokazujÄ…cÄ… sumÄ™ 'IloÅ›Ä‡' dla kaÅ¼dej 'Kategoria'.

***

## ÅÄ…czenie danych  

W analizie czÄ™sto Å‚Ä…czymy rÃ³Å¼ne zbiory danych, np. wynikajÄ…ce z rÃ³Å¼nych ÅºrÃ³deÅ‚.

### `concat`  

ÅÄ…czy DataFrameâ€™ y pionowo lub poziomo.  

```python
df1 = pd.DataFrame({'A': [1, 2], 'B': [3, 4]})
df2 = pd.DataFrame({'A': [5, 6], 'B': [7, 8]})

result = pd.concat([df1, df2])

print(result)
```

Parametr `axis`:

```python
# ÅÄ…czenie DataFrame w pionie (axis=0, domyÅ›lnie)
concat_pion = pd.concat([df1, df2], axis=0)
print("Pionowo (axis=0):")
print(concat_pion)

# ÅÄ…czenie DataFrame w poziomie (axis=1)
concat_poziom = pd.concat([df1, df2], axis=1)
print("\nPoziomo (axis=1):")
print(concat_poziom)
```

Zadanie: PoÅ‚Ä…cz df1 i df2 i wyÅ›wietl wynik.

***

### `merge`  

ÅÄ…czy dane na podstawie wspÃ³lnych kolumn (join).  

```python
left = pd.DataFrame({'klucz': ['a', 'b', 'c'], 'left_val': [1, 2, 3]})
right = pd.DataFrame({'klucz': ['b', 'c', 'd'], 'right_val': [4, 5, 6]})

merged = pd.merge(left, right, on='klucz', how='inner')

print(merged)
```

```python
# ğŸ”¹ Przygotowanie przykÅ‚adowych danych
df1 = pd.DataFrame({
    'key': ['A', 'B', 'C'],
    'value_df1': [1, 2, 3]
})

df2 = pd.DataFrame({
    'key': ['B', 'C', 'D'],
    'value_df2': [10, 20, 30]
})
```

#### ğŸ”¸ 1. INNER JOIN â€“ tylko wspÃ³lne klucze

```python
inner_join = pd.merge(df1, df2, on='key', how='inner')
print("INNER JOIN:")
print(inner_join, "\n")
```

#### ğŸ”¸ 2. LEFT JOIN â€“ wszystkie wiersze z df1, dopasowania z df2 (reszta NaN)

```python
left_join = pd.merge(df1, df2, on='key', how='left')
print("LEFT JOIN:")
print(left_join, "\n")
```

#### ğŸ”¸ 3. RIGHT JOIN â€“ wszystkie wiersze z df2, dopasowania z df1

```python
right_join = pd.merge(df1, df2, on='key', how='right')
print("RIGHT JOIN:")
print(right_join, "\n")
```

#### ğŸ”¸ 4. OUTER JOIN â€“ wszystkie wiersze z obu tabel

```python
outer_join = pd.merge(df1, df2, on='key', how='outer')
print("OUTER JOIN:")
print(outer_join, "\n")
```

#### ğŸ”¸ 5. CROSS JOIN â€“ kaÅ¼da kombinacja wierszy z df1 i df2

```python
cross_join = df1.merge(df2, how='cross')
print("CROSS JOIN:")
print(cross_join)
```

Zadanie: PoÅ‚Ä…cz lewy i prawy DataFrame dostÄ™pne w przykÅ‚adzie i wyÅ›wietl wynik zÅ‚Ä…czony po kolumnie 'klucz'.
